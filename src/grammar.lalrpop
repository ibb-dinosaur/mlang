use crate::ast::*;
use crate::lexer::*;
use crate::util::Either;

grammar;

pub Prog: Program = {
    nl* <definitions:Def*> => {
        let (tys, fns) = Either::collect_separate(definitions.into_iter());
        Program::new(fns, tys)
    }
}

Def: Either<TypeDefinition, Function> = {
    <t:TypeDef> => Either::Left(t),
    <f:Func> => Either::Right(f),
}

TypeDef: TypeDefinition = {
    "type" <name:LocIdent> "=" nl <fields:(<Param> nl)*> "end" nl* => {
        TypeDefinition { name: name.0, fields, loc: name.1 }
    }
}
 
Func: Function = {
    "fun" <name:LocIdent> "(" <params:CommaList<Param>> ")" <ret: (":" <TyExpr>)?> <body:FuncBody> nl* => {
        Function {
            name: name.0,
            params,
            return_type: ret.unwrap_or(Ty::Unk),
            body,
            loc: name.1
        }
    }
}

FuncBody: Vec<Stmt> = {
    "end" => vec![],
    nl <b:Block> "end" => b,
}

Param: (String, Ty) = {
    <name:ident> ":" <ty:TyExpr> => (name, ty),
    <name:ident> => (name, Ty::Any)
}

TyName: Ty = {
    <n:ident> => Ty::Named(n),
    "(" <TyExpr> ")"
}

TyExpr: Ty = {
    "fun" "(" <params:CommaList<TyName>> ")" <ret:("->" <TyName>)?> => Ty::Func(Box::new(ret.unwrap_or(Ty::Void)), params.into()),
    <t:TyName> "?" => Ty::Option(Box::new(t)),
    TyName
}

Block: Vec<Stmt> = {
    <stmts: (<LocS<Stmt>> nl+)*> => {
        stmts
    }
}

Stmt: Statement = {
    IfStmt,
    "return" <e:Loc<Expr>> => Statement::Return(e),
    "let" <name:ident> "=" <e:Loc<Expr>> => Statement::Let(name, e),
    <lhs:Loc<Expr>> "=" <e:Loc<Expr>> => Statement::Assign(lhs, e),
    <e:Loc<Expr>> => Statement::ExprStmt(e)
}

IfStmt: Statement = {
    "if" <cond:Loc<Expr>> "then" nl <then:Block> <elseifs:ElseIf*> <else_:("else" nl <Block>)?> "end" => {
        let else_ = else_.unwrap_or(vec![]);
        let mut elseifs = elseifs;
        elseifs.insert(0, (cond, then));
        elseifs.into_iter().rev().fold(else_, |else_, (cond, then)| {
            let loc = match else_.last() {
                Some(s) => SourceLoc::new_merged(&cond.loc, &s.loc),
                None => cond.loc.clone(),
            };
            vec![Stmt::located(Statement::If(cond, then, else_), loc)]
        }).pop().unwrap().s
    }
}

ElseIf: (Expr, Vec<Stmt>) = {
    "elseif" <cond:Loc<Expr>> "then" nl <then:Block> => (cond, then),
}

Expr: Expr = {
    CmpExpr
};

CmpExpr: Expr = {
    <lhs:Loc<AddExpr>> <op:CmpOp> <rhs:Loc<AddExpr>> => ExprKind::BinOp(op, Box::new(lhs), Box::new(rhs)).expr(),
    AddExpr
}

AddExpr: Expr = {
    BinOpL<Loc<Factor>, AddOp>
}

Factor: Expr = {
    BinOpL<Loc<Call>, MulOp>
}

Call: Expr = {
    <a:Loc<Atom>> "(" <args:CommaList<Loc<Expr>>> ")" => ExprKind::Call(Box::new(a), args).expr(),
    "new" <ty:ident> "(" <args:CommaList<Loc<Expr>>> ")" => ExprKind::New(Ty::Named(ty), args).expr(),
    <obj:Loc<Call>> "." <field:ident> => ExprKind::Field(Box::new(obj), field).expr(),
    <a:Loc<Atom>> => a,
};

Atom: Expr = {
    <v:ident> => ExprKind::Var(v).expr(),
    <n:int> => ExprKind::Literal(Literal::Int(n)).expr(),
    "true" => ExprKind::Literal(Literal::Bool(true)).expr(),
    "false" => ExprKind::Literal(Literal::Bool(false)).expr(),
    "null" => ExprKind::Literal(Literal::Null).expr(),
    "(" <e:Loc<Expr>> ")" => e,
};

CmpOp: BinOp = {
    "==" => BinOp::CmpEq,
    "!=" => BinOp::CmpNe,
    "<" => BinOp::CmpLt,
    "<=" => BinOp::CmpLe,
    ">" => BinOp::CmpGt,
    ">=" => BinOp::CmpGe,
}

AddOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

MulOp: BinOp = {
    "*" => BinOp::Mul,
}

CommaList<T>: Vec<T> = {
    <v:(<T> ",")+> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    },
    <e:T> => vec![e],
    => vec![],
};

BinOpL<T, O>: Expr = {
    <lhs:BinOpL<T, O>> <op:O> <rhs:T> => ExprKind::BinOp(op, Box::new(lhs), Box::new(rhs)).expr(),
    <e:T> => e,
}

LocIdent: (String, SourceLoc) = {
    <start:@L> <name:ident> <end:@R> => (name, (start, end).into()),
}

// locate statement
LocS<T>: Stmt = {
    <start:@L> <s:T> <end:@R> => Stmt::located(s, (start, end)),
}

// locate expression
Loc<T>: Expr = {
    <start:@L> <e:T> <end:@R> => e.located((start, end)),
}

extern {
    type Location = LexerLoc;
    type Error = LexerError;

    enum Token {
        ident => Token::Ident(<String>),
        int => Token::Int(<i64>),
        nl => Token::Nl,
        "fun" => Token::KwFun,
        "return" => Token::KwReturn,
        "let" => Token::KwLet,
        "true" => Token::KwTrue,
        "false" => Token::KwFalse,
        "if" => Token::KwIf,
        "else" => Token::KwElse,
        "elseif" => Token::KwElseif,
        "then" => Token::KwThen,
        "end" => Token::KwEnd,
        "type" => Token::KwType,
        "new" => Token::KwNew,
        "null" => Token::KwNull,
        "(" => Token::LParen,
        ")" => Token::RParen,
        ":" => Token::Colon,
        "," => Token::Comma,
        "=" => Token::Assign,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "->" => Token::Arrow,
        "==" => Token::Eq,
        "!=" => Token::Ne,
        "<" => Token::Lt,
        "<=" => Token::Le,
        ">" => Token::Gt,
        ">=" => Token::Ge,
        "." => Token::Dot,
        "?" => Token::QMark,
    }
}