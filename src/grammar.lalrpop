use crate::ast::*;
use crate::lexer::*;
use crate::util::Either;

grammar;

pub Prog: Program = {
    nl* <definitions:Def*> => {
        let (tys, fns) = Either::collect_separate(definitions.into_iter());
        Program::new(fns, tys)
    }
}

Def: Either<TypeDefinition, Function> = {
    <t:TypeDef> => Either::Left(t),
    <f:Func> => Either::Right(f),
}

TypeDef: TypeDefinition = {
    "type" <name:ident> "=" nl <fields:(<Param> nl)*> "end" nl* => {
        TypeDefinition { name, fields }
    }
}
 
Func: Function = {
    "fun" <name:ident> "(" <params:CommaList<Param>> ")" <ret: (":" <TyExpr>)?> <body:FuncBody> nl* => {
        Function {
            name,
            params,
            return_type: ret.unwrap_or(Ty::Unk),
            body,
        }
    }
}

FuncBody: Vec<Statement> = {
    "end" => vec![],
    nl <b:Block> "end" => b,
}

Param: (String, Ty) = {
    <name:ident> ":" <ty:TyExpr> => (name, ty),
    <name:ident> => (name, Ty::Any)
}

TyName: Ty = {
    <n:ident> => Ty::Named(n),
    "(" <TyExpr> ")"
}

TyExpr: Ty = {
    "fun" "(" <params:CommaList<TyName>> ")" <ret:("->" <TyName>)?> => Ty::Func(Box::new(ret.unwrap_or(Ty::Void)), params.into()),
    TyName
}

Block: Vec<Statement> = {
    <stmts: (<Stmt> nl+)*> => {
        stmts
    }
}

Stmt: Statement = {
    IfStmt,
    "return" <e:Expr> => Statement::Return(e),
    "let" <name:ident> "=" <e:Expr> => Statement::Let(name, e),
    <var:ident> "=" <e:Expr> => Statement::Assign(var, e),
    <e:Expr> => Statement::ExprStmt(e)
}

IfStmt: Statement = {
    "if" <cond:Expr> "then" nl <then:Block> <elseifs:ElseIf*> <else_:("else" nl <Block>)?> "end" => {
        let else_ = else_.unwrap_or(vec![]);
        let mut elseifs = elseifs;
        elseifs.insert(0, (cond, then));
        elseifs.into_iter().rev().fold(else_, |else_, (cond, then)| {
            vec![Statement::If(cond, then, else_)]
        }).pop().unwrap()
    }
}

ElseIf: (Expr, Vec<Statement>) = {
    "elseif" <cond:Expr> "then" nl <then:Block> => (cond, then),
}

Expr: Expr = {
    CmpExpr
};

CmpExpr: Expr = {
    <lhs:AddExpr> <op:CmpOp> <rhs:AddExpr> => ExprKind::BinOp(op, Box::new(lhs), Box::new(rhs)).expr(),
    AddExpr
}

AddExpr: Expr = {
    BinOpL<Factor, AddOp>
}

Factor: Expr = {
    BinOpL<Call, MulOp>
}

Call: Expr = {
    <a:Atom> "(" <args:CommaList<Expr>> ")" => ExprKind::Call(Box::new(a), args).expr(),
    "new" <ty:ident> "(" <args:CommaList<Expr>> ")" => ExprKind::New(Ty::Named(ty), args).expr(),
    <a:Atom> => a,
};

Atom: Expr = {
    <v:ident> => ExprKind::Var(v).expr(),
    <n:int> => ExprKind::Literal(Literal::Int(n)).expr(),
    "true" => ExprKind::Literal(Literal::Bool(true)).expr(),
    "false" => ExprKind::Literal(Literal::Bool(false)).expr(),
    "(" <e:Expr> ")" => e,
};

CmpOp: BinOp = {
    "==" => BinOp::CmpEq,
    "!=" => BinOp::CmpNe,
    "<" => BinOp::CmpLt,
    "<=" => BinOp::CmpLe,
    ">" => BinOp::CmpGt,
    ">=" => BinOp::CmpGe,
}

AddOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

MulOp: BinOp = {
    "*" => BinOp::Mul,
}

CommaList<T>: Vec<T> = {
    <v:(<T> ",")+> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    },
    <e:T> => vec![e],
    => vec![],
};

BinOpL<T, O>: Expr = {
    <lhs:BinOpL<T, O>> <op:O> <rhs:T> => ExprKind::BinOp(op, Box::new(lhs), Box::new(rhs)).expr(),
    <e:T> => e,
}

extern {
    type Location = usize;
    type Error = LexerError;

    enum Token {
        ident => Token::Ident(<String>),
        int => Token::Int(<i64>),
        nl => Token::Nl,
        "fun" => Token::KwFun,
        "return" => Token::KwReturn,
        "let" => Token::KwLet,
        "true" => Token::KwTrue,
        "false" => Token::KwFalse,
        "if" => Token::KwIf,
        "else" => Token::KwElse,
        "elseif" => Token::KwElseif,
        "then" => Token::KwThen,
        "end" => Token::KwEnd,
        "type" => Token::KwType,
        "new" => Token::KwNew,
        "(" => Token::LParen,
        ")" => Token::RParen,
        ":" => Token::Colon,
        "," => Token::Comma,
        "=" => Token::Assign,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "->" => Token::Arrow,
        "==" => Token::Eq,
        "!=" => Token::Ne,
        "<" => Token::Lt,
        "<=" => Token::Le,
        ">" => Token::Gt,
        ">=" => Token::Ge,
    }
}